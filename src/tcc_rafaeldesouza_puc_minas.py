# -*- coding: utf-8 -*-
"""TCC-PUC-RAFAELDESOUZA.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DTLDFc-bLCJTrRgQNf6c_7A1Nfc578cM
"""

# importação da biblioteca "pandas" com o alias "pd"
import pandas as pd  

# carregamento do dados exportados do banco de dados para um dataframe do pandas
dataset = pd.read_csv('dataset2.csv') 
# apresentação dos dados em tela para verificação do correto carregamento
print(dataset)

# carregamento das três variáveis a serem processadas em um novo dataframe pandas
# desconsiderando a coluna 'ValHouveEnchente' que é a coluna onde está armazenada 
# o resultado esperado
X = dataset.drop(['ValHouveEnchente'],axis=1).values
# aplicação da fórmula da normalização Z-score, onde a média é substraida dos 
# valores originais e posteriormente divididos pelo desvio padrão
X = (X -X.mean()) / X.std()
X

X_validacao = X[-10:]
X = X[0:-10]

# carregamento dos dados da coluna 'ValHouveEnchente' em um dataframe pandas
# específico, esse dataframe será utilizado como base para determinar os resultados
# esperados, os quais a RNA usará para medir o progresso do seu aprendizado
y = dataset['ValHouveEnchente'].values

y_validacao = y[-10:]
y_validacao

y = y[0:-10]
y

# importação da biblioteca scikit-learn para separação dos datasets em carga de 
# treino e teste
from sklearn.model_selection import train_test_split

# separação dos datasets em 80% para treino e 20# para teste
# X_treino é a carga de dados para treinar a RNA
# X_teste são os dados separados para testar a RNA
# y_treino são os resultados esperados de cada conjunto presente no dataset de treino
# y_teste são os resultados esperados de cada conjunto presente no dataset de teste
X_treino, X_teste, y_treino, y_teste = train_test_split(X, y, test_size=0.2)

# importação da biblioteca PyTorch
import torch

# tranformação dos datasets em tensores do PyTorch
X_treino = torch.FloatTensor(X_treino)
X_teste = torch.FloatTensor(X_teste)
y_treino = torch.LongTensor(y_treino)
y_teste = torch.LongTensor(y_teste)

# importação das bibliotecas nn e nn.functional
import torch.nn as nn
import torch.nn.functional as F

# defiição da RNA
class RedeNeuralArtificial(nn.Module):
  #
  def __init__(self,entrada=3,camada_escondida1=64,camada_escondida2=128,saida=2):
    super().__init__()
    self.fc1 = nn.Linear(entrada,camada_escondida1)
    self.fc2 = nn.Linear(camada_escondida1, camada_escondida2)
    self.out = nn.Linear(camada_escondida2, saida)
  
# a função forward é responsável por realizar a ativição entre as camadas da RNA
# a saída esperada da rede é sempre positivia e por isso a função ReLU é utilizada 
# para realizar a essa tarefa
  def forward(self, x):
    x = F.relu(self.fc1(x))
    x = F.relu(self.fc2(x))
    x = self.out(x)
    return x

# instanciação da classe RNA
modelo_classificacao = RedeNeuralArtificial()

# a função de medida de performance foi definida como Entropia Cruzada
# esta função é responsável por medir se a RNA está se aproximando do resultado esperado
funcao_performance = nn.CrossEntropyLoss()

# como os pesos iniciais atribuidos a cada neurônio são aleatórios, é necessário 
# utilizar um otimizador para ajustar esse valores conforme o treinamendo da RNA
# avança, neste caso foi utilizado o Algortimo de Adam
otimizador = torch.optim.Adam(modelo_classificacao.parameters(), lr=0.01)

# a variável 'epocas' determina a quantidade de vezes que os dados serão
# passados pela RNA para treiná-la
epocas = 100
epc = []
custos = []

for i in range(epocas):
  # retorna o valor predito
  y_predito = modelo_classificacao.forward(X_treino)
  # calcula o custo 
  custo = funcao_performance(y_predito, y_treino)
  # dados armazenados em listas apenas para plotagem de gráfico
  custos.append(custo.item())
  epc.append(i+1)

# função zero_grad() tem por objetivo definir o gradiente como 0 antes de iniciar o
# processo de retropropagação
  otimizador.zero_grad()
# função backward() realiza o cálculo do gradiente
  custo.backward()
# atualiza os dados do otimizador conforme o gradiante atual
  otimizador.step()

print(("%.17f" % custos[-1:][0]).rstrip('0').rstrip('.'))

import matplotlib.pyplot as plt

plt.plot(epc, custos)
plt.title('Comportamento do Custo')
plt.xlabel('Época')
plt.ylabel('Custo')
plt.show()

predicoes = []

with torch.no_grad():
    for val in X_teste:
        y_predito = modelo_classificacao.forward(val)
        # print(y_predito)
        predicoes.append(y_predito.argmax().item())

df = pd.DataFrame({'Esperado': y_teste, 'Predição': predicoes})
df['Correto'] = [1 if corr == pred else 0 for corr, pred in zip(df['Esperado'], df['Predição'])]
df

X_val = torch.FloatTensor(X_validacao)
y_val = torch.LongTensor(y_validacao)

predicoes_novo =[]

with torch.no_grad():
    for val in X_val:
        y_predito_novo = modelo_classificacao.forward(val)
        predicoes_novo.append(y_predito_novo.argmax().item())

df2 = pd.DataFrame({'Esperado': y_val, 'Predição': predicoes_novo})
df2['Correto'] = [1 if corr == pred else 0 for corr, pred in zip(df2['Esperado'], df2['Predição'])]
df2